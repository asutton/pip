
\section{Introduction}

%% Answer the following questions:
%% \begin{itemize}
%% \item What is the problem we are solving?
%% \item How are we going to solve the problem?
%% \item What did we do?
%% \item What are the results?
%% \item What are our contributions?
%% \end{itemize}

Conventional switches are configured using vendor-specific interfaces that lack scalability and flexibility. In addition, manual switch configuration is heavily prone to error and compromise. Software-defined networking (SDN) is a paradigm that helps to mitigate user error in packet switching and increase network scalability by allowing switches to be programmed through a high-level programming language. However, there is no standard language for SDN, some programmers have tried to use C or Python, others have developed domain-specific languages to achieve these purposes. There are problems using both general purpose languages and domain-specific languages. The semantics of general purpose languages allow program constructs that allow for invocation of undefined behaviors (buffer overflow, pointer errors, data races, and so on). On the other hand, domain-specific languages, may not be sufficient to express the kinds of computations necessary for higher-level SDN applications. We attempted to build a virtual system for SDN that allows to study and reason about SDN programs, allowing us to identify what properties of a language are most useful for safely and efficiently supporting SDN.

%% Problem: We want either to build a programming language for SDN, or to identify existing languages that might extended to safely and efficiently support SDN.
%% To do this, we need to find a ``sweet spot'' between the two extremes of fully general vs. highly specific languages.

%% \textbf{How did we approach the problem}.
Our approach is to create a minimal abstract machine to represent the kinds of computational facility present in a typical OpenFlow-like data plane.
The description of our abstract machine includes basic notions of state and the smallest possible set of operations needed to define SDN programs.
In essence, we attempted to construct an assembly language for OpenFlow-style packet processing. We defined the abstract syntax of a programming language and the operational semantics for this abstract machine. In order better experiment with it, we also implemented a virtual machine capable of executing SDN programs.

%% \textbf{How does the abstract machine help us study language design?}
Now that we have a model, we hope to start reasoning about higher level language constructs that support safe and efficient switch configurations. We hope to use our findings to construct minimal abstract machines out of subsets of other dataplane domain-specific languages. Operational semantics of a language give a good basis for proof through logic and dynamic logic. In the future, we would like to examine techniques for dynamic logical analysis of dataplane programs.

%% \textbf{What did we do?}

%% \begin{verbatim}
%% Talk about the clean separation of the data plane machine from the controller.
%% The controller has to be a GP language, the DP does not.
%% \end{verbatim}
The Pip language has no object model or declaration system, as well as minimal control structure. By removing much of the freedom present in general-purpose programming languages and restricting the programmer to simple packet-switching actions and buffer modification, Pip programs are able to maintain provable properties and provable termination. The operational semantics of Pip allow for a logical description of the state of the program at any time. In order to maintain these provable properties, we allow the programmer to output a modified packet to a ``controller'', a program written in a general-purpose programming language that has the facilities for mutable state or abstract-syntax tree modification.

%% Built experimental controllers to experiment with mutable program state.

%% \textbf{What did we find out?}
Our abstract machine provides a lot of opportunities for executing undefined behaviors. In particular, it is easy to build programs that read across packet boundaries, fail to validate input, etc. 

Separating the controller from the dataplane allows for packet switching to be reasoned about mathematically without introducing undecidable outcomes.

%% \textbf{Contributions}
%% \begin{enumerate}
%% \item Operational semantics for Pip
%% \item Identify opportunities for undefined behavior
%% \item Implementation of Pip
%% \item Experimental controller programs?s
%% \end{enumerate}

% The problem with typical programming languages is that the semantics of these programming languages are informally designed, often rife with side effects, and perhaps most pertinent for packet switching: prone to buffer overflows. We have presented a new domain specific programming language and virtual machine to model an OpenFlow-style network, with a formally-defined type system and structural operational semantics, thus allowing properties to be proven about software-defined networking programs.

This paper is organized as follows: Section 2 demonstrates the use of the Pip programming language to create simple SDN applications. Section 3 gives a detailed explanation of and serves as a reference to the Pip programming language. It provides proper documentation to the various language constructs of Pip.

Section 4 describes the abstract syntax of the Pip language, first presenting the types and expressions of the language before defining the proper formation of actions, or the instructions of the language. Section 5 explains the operational semantics and state of the machine, and shows a transition relation for all actions presented in Section 4.

Section 6 describes the implementation of the virtual machine and language interpreter.

Section 7 provides discussion of some undefined behaviors and issues with the language. Section 8 discusses future work and solutions to the issues of Pip discovered in related work.
