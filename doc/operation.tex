
\section{Operational Semantics}

\subsection{Notation}
The state of the evaluator, $\sigma$, is the tuple consisting of \\
packet, $\pi$\\
action\_list, $\alpha$ \\
stored\_action\_list, $\Lambda$ \\
\textbf{context}, which is the tuple: \\
$\langle ingress\_port, \ egress\_port, \ physical\_port, \ key, \ meta, \ header\_offset, \ table \rangle$ \\ \\
Compactly, $\sigma = \langle \pi, \alpha, \Lambda, \textbf{\textrm{context}} \rangle$
\\ \\
We can examine or change the status of $\pi$ or \textbf{context} by using the index operator, []. The index itself is context-sensitive: $\pi$ is indexed by some \textit{field}, \textbf{context} is indexed by one of its substructures.
A field in $\pi$ can be set to a literal value or copied from a bitfield or register. For example:
\begin{equation}
  \pi[\textit{field}] \leftarrow \textit{value}
\end{equation}
\begin{equation}
  \pi[\textit{field}] \leftarrow \mathbb{r}
\end{equation}
\begin{equation}
  \pi[\textit{field}] \leftarrow \textit{bitfield}
\end{equation}

Comments:
\begin{enumerate}
\item Field \textit{field} with a packet, $\pi$, is set to some literal value, \textit{value}.
\item The value of register $\mathbb{r}$ is copied into \textit{field}.
\item The value of some bitfield, \textit{bitfield} is copied into \textit{field}.
\end{enumerate}
\subsection{Operational Semantics 5-Tuple}
$ pip = \langle IF, \ CF, \ \Rightarrow, \ FC, \ OF \rangle $\\
IF = $program \times \pi \rightarrow CF$ \\
CF = $\alpha \times \xi \times \pi$ \\
$\Rightarrow$ = Defined in section ``Reduction Relation''. \\
FC = $(\Lambda = \emptyset) \times \pi \times \textbf{\textrm{context}}\langle egress\_port \neq 0 \rangle $ \\
OF = $FC \rightarrow \textrm{serialization}$

\subsection{Reduction Relation}
\setlength{\mathindent}{0pt}
\begin{equation}
\begin{split}
  (\textbf{\textrm{advance}} \ n)\textrm{,} \ \langle \pi, \ (\textrm{\textbf{advance}} \ \oplus \ \bar \alpha), \ \Lambda,
  \ \textrm{\textbf{context}}[header\_offset] \rangle \\ \Rightarrow \langle \pi, \ \bar \alpha, \ \Lambda,
  \ \textrm{\textbf{context}}[header\_offset + n] \rangle
\end{split}
\end{equation}

Advance the header offset by \textit{n} bits.

\begin{equation}
  (\textrm{\textbf{clear}}) \textrm{,} \ \langle \pi, \ (\textbf{\textrm{clear}} \ \oplus \ \bar \alpha), \ \bar \Lambda, \ \textrm{\textbf{context}} \rangle
  \Rightarrow \langle \pi, \ \bar \alpha, \ \emptyset, \  \textrm{\textbf{context}} \rangle
\end{equation}

Remove all actions from stored action list, $\Lambda$.

\begin{equation}  
  (\textrm{\textbf{drop})} \textrm{,} \ \langle \pi, \ (\textrm{\textbf{drop}} \ \oplus \ \bar \alpha), \ \bar \Lambda, \textbf{\textrm{context}} \rangle
  \Rightarrow \langle \emptyset \rangle
\end{equation}

Remove all actions from the action list, $\alpha$, thus discontinuing packet processing.

\begin{equation}
  (\textrm{\textbf{write}} \ action), \ \langle \pi, \ (\textrm{\textbf{write}} \ \oplus \ \bar \alpha), \ \bar \Lambda,
  \textrm{\textbf{context}} \rangle \Rightarrow
  \langle \pi, \ \bar \alpha, \ \bar \Lambda \cdot action, \textrm{\textbf{context}} \rangle
\end{equation}

Append \textit{action} to stored action list, $\Lambda$.

\begin{equation}
  (\textrm{\textbf{goto}} \ \tau) \textrm{,} \ \langle \pi, \ (\textrm{\textbf{goto}} \ \oplus \ \bar \alpha), \ \bar \Lambda, \textrm{\textbf{context}}[table] \rangle
  \Rightarrow \langle \pi, \ \bar \alpha, \ \bar \Lambda, \textrm{\textbf{context}}[\tau] \rangle
\end{equation}

Change the \textbf{current\_table} variable in the context to $\tau$.

\begin{equation}
\begin{split}
  (\textrm{\textbf{set}} \ field \ value) \textrm{,} \ \langle \pi, (\textrm{\textbf{set}} \ \oplus \ \bar \alpha), \bar \Lambda,
  \textbf{\textrm{context}}[field] \rangle \\
  \Rightarrow \langle \pi, \bar \alpha, \bar \Lambda,
  \textbf{\textrm{context}}[field] = value \rangle
\end{split}
\end{equation}

Set the bitfield, \textit{field}, to the literal value, \textit{value}.

\begin{equation}
\begin{split}
  (\textrm{\textbf{output}} \ port) \textrm{,} \ \langle \pi, (\textrm{\textbf{output}} \ \oplus \ \bar \alpha), \bar \Lambda,
  \textbf{\textrm{context}}[egress\_port] \rangle \\
  \Rightarrow 
  \langle \pi, \bar \alpha, \bar \Lambda,
  \textbf{\textrm{context}}[egress\_port] = port \rangle
\end{split}
\end{equation}

Change the \textbf{egress\_port} variable in the context to \textit{port}, thus outputting the packet to \textit{port}.

\begin{equation}
\begin{split}
  (\textrm{\textbf{copy}} \ as_1 \ src \ as_2 \ dst \ n)
  \textrm{,} \ \langle \pi[dst], (\textbf{\textrm{copy}} \ \oplus \ \bar \alpha), \bar \Lambda, \textrm{\textbf{context}}[dst] \rangle \\ \Rightarrow
  \langle \pi[dst] = [meta, meta + n), \bar \alpha, \bar \Lambda, \textrm{\textbf{context}} \rangle \\
    \textrm{where} \ as_1 = \textrm{\textbf{meta} and } as_2 =
    \textrm{\textbf{packet}}
\end{split}
\end{equation}

\begin{equation}
\begin{split}
  (\textrm{\textbf{copy}} \ as_1 \ src \ as_2 \ dst \ n)
  \textrm{,} \ \langle \pi[dst + header\_offset], (\textbf{\textrm{copy}} \ \oplus \ \bar \alpha), \bar \Lambda, \textrm{\textbf{context}} \rangle \\
  \Rightarrow
  \langle \pi[dst + header\_offset] = [meta, meta + n), \bar \alpha, \bar \Lambda, \textrm{\textbf{context}} \rangle \\
    \textrm{where} \ as_1 = \textrm{\textbf{meta} and } as_2 =
    \textrm{\textbf{header}}
\end{split}
\end{equation}

\begin{equation}
\begin{split}
  (\textrm{\textbf{copy}} \ as_1 \ src \ as_2 \ dst \ n)
  \textrm{,} \ \langle \pi, (\textrm{\textbf{copy}} \ \oplus \ \bar \alpha), \bar \Lambda, \textrm{\textbf{context}[key]} \rangle \\
  \Rightarrow
  \langle \pi, \bar \alpha, \bar \Lambda, \textrm{\textbf{context}[key]} = [meta, meta + n) \rangle \\
    \textrm{where} \ as_1 = \textrm{\textbf{meta} and } as_2 =
    \textrm{\textbf{key}}
\end{split}
\end{equation}

\begin{equation}
\begin{split}
  (\textrm{\textbf{copy}} \ as_1 \ src \ as_2 \ dst \ n)
  \textrm{,} \ \langle \pi[dst + header\_offset], (\textrm{\textbf{copy}} \ \oplus \ \bar \alpha), \bar \Lambda, \textrm{\textbf{context}} \rangle \\
  \Rightarrow
  \langle \pi[dst + header\_offset] = [meta, meta + n), (\textrm{\textbf{copy}} \ \oplus \ \bar \alpha), \bar \Lambda, \textrm{\textbf{context}} \rangle \\
    \textrm{where} \ as_1 = \textrm{\textbf{meta} and } as_2 =
    \textrm{\textbf{header}}
\end{split}
\end{equation}

\begin{equation}
\begin{split}
  (\textrm{\textbf{copy}} \ as_1 \ src \ as_2 \ dst \ n)
  \textrm{,} \ \langle \pi[dst], (\textrm{\textbf{copy}} \ \oplus \ \bar \alpha), \bar \Lambda, \textrm{\textbf{context}} \rangle \\
  \Rightarrow 
  \langle \pi[dst] = [src, src + n), \bar \alpha, \bar \Lambda, \textrm{\textbf{context}} \rangle \\
    \textrm{where} \ as_1 = \textrm{\textbf{packet} and } as_2 =
    \textrm{\textbf{packet}}
\end{split}
\end{equation}

\begin{equation}
\begin{split}
  (\textrm{\textbf{copy}} \ as_1 \ src \ as_2 \ dst \ n)
  \textrm{,} \ \langle \pi[dst + header\_offset], (\textrm{\textbf{copy}} \ \oplus \ \bar \alpha), \bar \Lambda, \textrm{\textbf{context}} \rangle \\
  \Rightarrow
  \langle \pi[dst + header\_offset] = [src, src + n), \bar \alpha, \bar \Lambda, \textrm{\textbf{context}} \rangle \\
    \textrm{where} \ as_1 = \textrm{\textbf{packet} and } as_2 =
    \textrm{\textbf{header}}
\end{split}
\end{equation}

\begin{equation}
\begin{split}
  (\textrm{\textbf{copy}} \ as_1 \ src \ as_2 \ dst \ n)
  \textrm{,} \ \langle \pi[src], (\textrm{\textbf{copy}} \ \oplus \ \bar \alpha), \bar \Lambda, \textrm{\textbf{context}}[key] \rangle \\
  \Rightarrow
  \langle \pi[src], \bar \alpha, \bar \Lambda, \textrm{\textbf{context}}[key] = \pi[src] \rangle \\
    \textrm{where} \ as_1 = \textrm{\textbf{packet} and } as_2 =
    \textrm{\textbf{key}}
\end{split}
\end{equation}

\begin{equation}
\begin{split}
  (\textrm{\textbf{copy}} \ as_1 \ src \ as_2 \ dst \ n)
  \textrm{,} \ \langle \pi[dst + header\_offset], (\textrm{\textbf{copy}} \ \oplus \ \bar \alpha), \bar \Lambda, \textrm{\textbf{context}} \rangle \\
  \Rightarrow
  \langle \pi[dst + header\_offset] = \\ \pi[src + header\_offset, src + header\_offset + n),
  \bar \alpha, \bar \Lambda, \textrm{\textbf{context}} \rangle \\
    \textrm{where} \ as_1 = \textrm{\textbf{header} and } as_2 =
    \textrm{\textbf{header}}
\end{split}
\end{equation}

\begin{equation}
\begin{split}
  (\textrm{\textbf{copy}} \ as_1 \ src \ as_2 \ dst \ n)
  \textrm{,} \\ \langle \pi[src + header\_offset] \wedge \pi[dst], (\textrm{\textbf{copy}} \ \oplus \ \bar \alpha), \bar \Lambda, \textrm{\textbf{context}} \rangle \\  
  \Rightarrow
  \langle \pi[dst] = \pi[[src + header\_offset, src + header\_offset + n], \bar \alpha, \bar \Lambda, \textrm{\textbf{context}} \rangle \\  
    \textrm{where} \ as_1 = \textrm{\textbf{header} and } as_2 =
    \textrm{\textbf{packet}}
\end{split}
\end{equation}

\begin{equation}
\begin{split}
  (\textrm{\textbf{copy}} \ as_1 \ src \ as_2 \ dst \ n)
  \textrm{,} \ \langle \pi, (\textrm{\textbf{copy}} \ \oplus \ \bar \alpha), \bar \Lambda, \textrm{\textbf{context}} \rangle \\
  \Rightarrow
  \langle \pi, \bar \alpha, \bar \Lambda, \textrm{\textbf{context}}[key] = \\\pi[[src + header\_offset, src + header\_offset + n)] \rangle \\
    \textrm{where} \ as_1 = \textrm{\textbf{header} and } as_2 =
    \textrm{\textbf{key}}
\end{split}
\end{equation}

\begin{equation}
\begin{split}
  (\textrm{\textbf{copy}} \ as_1 \ src \ as_2 \ dst \ n)
  \textrm{,} \ \langle \pi, (\textrm{\textbf{copy}} \ \oplus \ \bar \alpha), \bar \Lambda, \textrm{\textbf{context}} \rangle \\
  \Rightarrow
  \langle \pi, \bar \alpha, \bar \Lambda, \textrm{\textbf{context}}[meta] = \\ \pi[[src + header\_offset, src + header\_offset + n)] \rangle \\
    \textrm{where} \ as_1 = \textrm{\textbf{header} and } as_2 =
    \textrm{\textbf{meta}}
\end{split}
\end{equation}
