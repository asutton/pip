
\section{Operational Semantics}

\subsection{Notation}

The state of the evaluator, $\sigma$, is the tuple consisting of \\
packet, $\pi$\\
action\_list, $\alpha$ \\
stored\_action\_list, $\Lambda$ \\
\textbf{context}, which is the tuple: \\
$\langle ingress\_port, \ egress\_port, \ physical\_port, \ key, \ meta, \ header\_offset, \ table \rangle$ \\ \\
Compactly, $\sigma = \langle \pi, \alpha, \Lambda, \textbf{\textrm{context}} \rangle$
\\ \\
We can examine or change the status of $\pi$ or \textbf{context} by using the index operator, []. The index itself is context-sensitive: $\pi$ is indexed by some \textit{field}, \textbf{context} is indexed by one of its substructures.
A field in $\pi$ can be set to a literal value or copied from a bitfield or register. For example:
\begin{equation}
  \pi[\textit{field}] \leftarrow \textit{value}
\end{equation}
\begin{equation}
  \pi[\textit{field}] \leftarrow \mathbb{r}
\end{equation}
\begin{equation}
  \pi[\textit{field}] \leftarrow \textit{bitfield}
\end{equation}

Comments:
\begin{enumerate}
\item Field \textit{field} with a packet, $\pi$, is set to some literal value, \textit{value}.
\item The value of register $\mathbb{r}$ is copied into \textit{field}.
\item The value of some bitfield, \textit{bitfield} is copied into \textit{field}.
\end{enumerate}


\subsection{Operational Semantics 5-Tuple}
% $ pip = \langle IF, \ CF, \ \Rightarrow, \ FC, \ OF \rangle $\\
% IF = $program \times \pi \rightarrow CF$ \\
% CF = $\alpha \times \xi \times \pi$ \\
% $\Rightarrow$ = Defined in section ``Reduction Relation''. \\
% FC = $(\Lambda = \emptyset) \times \pi \times \textbf{\textrm{context}}\langle egress\_port \neq 0 \rangle $ \\
% OF = $FC \rightarrow \textrm{serialization}$

\subsection{Reduction Relation}
\setlength{\mathindent}{0pt}

\begin{mdframed}
\begin{gather*}
  (\mathct{advance}~n \cdot \bar\alpha), \langle \pi, \Lambda, \Gamma \rangle
  \Rightarrow
  (\bar\alpha), \langle \pi, \Lambda, \Gamma[\mathct{header}
  \leftarrow \mathct{header} + n] \rangle
\\
  (\mathct{clear} \cdot \bar\alpha), \langle \pi, \Lambda, \Gamma \rangle
  \Rightarrow
  (\bar\alpha), \langle \pi, \varnothing, \Gamma \rangle
\\
  (\mathct{drop} \cdot \bar\alpha), \langle \pi, \Lambda, \Gamma \rangle
  \Rightarrow
  \varnothing, \langle \pi, \varnothing, \Gamma [\mathct{out} \leftarrow 0] \rangle
\\
  (\mathct{write} \ \textit{action} \cdot \bar\alpha), \langle \pi, \Lambda,
  \Gamma \rangle
  \Rightarrow
  (\bar\alpha), \langle \pi, \Lambda \cdot \textit{action}, \Gamma \rangle
\\
  (\mathct{goto} \ T \cdot \bar\alpha),
  \langle \pi, \Lambda, \Gamma \rangle
  \Rightarrow
  (\bar\alpha), \langle \pi, \Lambda,
  \Gamma[\mathct{current\_table} \leftarrow T] \rangle
\\
  (\mathct{set} \ \textit{field} \ \textit{value} \cdot \bar\alpha), \langle \pi,
  \Lambda, \Gamma \rangle
  \Rightarrow
  (\bar\alpha), \langle \pi', \Lambda, \Gamma' \rangle
\\
  (\mathct{output} \ \mathct{port} \ n \cdot \bar \alpha), \langle \pi, \Lambda,
  \Gamma \rangle
  \Rightarrow
  (\bar\alpha), \langle \pi, \Lambda, \Gamma[\mathct{egress\_port}
  \leftarrow \mathct{port} \ n] \rangle
\\
  (\mathct{copy} \ as_1 \ src \ as_2 \ dst \cdot \bar\alpha), \langle \pi,
  \Lambda, \Gamma \rangle
  \Rightarrow
  (\bar\alpha), \langle \pi', \Lambda, \Gamma' \rangle
\end{gather*}
\end{mdframed}

The $\mathct{advance}$ command advances the header offset by \textit{n} bits.
This can be used by a programmer to adjust the decoding offset relative to a
packet header.
The $\mathct{clear}$ command clears the stored action list. This can be used
by a program reset any accumulated actions if certain conditions are detected
during packet analysis (e.g., filtering flows based on UDP packet content).
The $\mathct{drop}$ command truncates both the action list and stored action list,
and sets the output port to 0 (the null port). 
The effect of this to cause the program to terminate such that the execution 
environment will not forward the packet.
The \mathct{write} command appends an action to the stored action list. This is
the only way to write to the stored action list, allowing for some action to be
taken upon egress, providing the packet is not dropped.
The \mathct{goto} command jumps from the current match table to a new table. The
key register is cleared and rewritten based on the new table's rules. This can
be used as a rudimentary control structure.
The \mathct{set} command sets a bitfield, \textit{field} to some value \textit{value}.
This is used to set fields to a literal value.
The \mathct{output} action outputs to the specified \mathct{port}, \textit{n}, beginning
egress processing.
The \mathct{copy} action copies from one bitfield, \textit{src} to another bitfield, \textit{dst}.
A bitfield can be copied from any address space to any other address space, except for key registers,
which cannot be used as a source.

Definition of copy function: (move to displaymath)
\begin{equation}
(\textrm{\textbf{copy}} \ meta \ src \ packet \ dst \ n) \Rightarrow
  \langle \pi[dst] = \textrm{\textbf{context.meta}[dst, dst + n)} \rangle
\end{equation}
\begin{equation}
  (\textrm{\textbf{copy}} \ meta \ src \ header \ dst \ n) \Rightarrow
  \langle \pi[dst + header\_offset] =
          \textrm{\textbf{context.meta}[dst, dst + n)} \rangle
\end{equation}
\begin{equation}
  (\textrm{\textbf{copy}} \ meta \ src \ key \ dst \ n) \Rightarrow
  \langle \textbf{\textrm{context.key}}[dst] =
          \textrm{\textbf{context.meta}[dst, dst + n]} \rangle
\end{equation}
\begin{equation}
  (\textrm{\textbf{copy}} \ meta \ src \ key \ dst \ n) \Rightarrow
  \langle \textbf{\textrm{context}}[key] =
          [meta, meta + n] \rangle
\end{equation}
\begin{equation}
  (\textrm{\textbf{copy}} \ packet \ src \ packet \ dst \ n) \Rightarrow
  \langle \pi[dst] = \pi[src, src + n) \rangle
\end{equation}
\begin{equation}
  (\textrm{\textbf{copy}} \ packet \ src \ header \ dst \ n) \Rightarrow
  \langle \pi[dst + header\_offset] = \pi[src, src + n) \rangle
\end{equation}
\begin{equation}
  (\textrm{\textbf{copy}} \ packet \ src \ key \ dst \ n) \Rightarrow
  \langle \textrm{\textbf{context.key}[dst]} = \pi[src, src + n) \rangle
\end{equation}
\begin{equation}
  (\textrm{\textbf{copy}} \ header \ src \ header \ dst \ n) \Rightarrow
  \langle \pi[dst + header\_offset] = \pi[src + header\_offset, src + header\_offset + n) \rangle
\end{equation}
\begin{equation}
  (\textrm{\textbf{copy}} \ header \ src \ packet \ dst \ n) \Rightarrow
  \langle \pi[dst] = \pi[src + header\_offset, src + header\_offset + n) \rangle
\end{equation}
\begin{equation}
  (\textrm{\textbf{copy}} \ header \ src \ key \ dst \ n) \Rightarrow
  \langle \textrm{\textbf{context.key}[dst]} = \pi[src + header\_offset, src + header\_offset + n) \rangle
\end{equation}
\begin{equation}
  (\textrm{\textbf{copy}} \ header \ src \ meta \ dst \ n) \Rightarrow
  \langle \textrm{\textbf{context.meta}[dst]} = \pi[src + header\_offset, src + header\_offset + n) \rangle
\end{equation}
