
\section{Type System}
Pip uses a type system to ensure semi-semantically correct instructions. Instructions, known as actions, can take well-formed expressions as parameters, 

\subsection{Types}

\begin{align*}
\tau ::=~& \mathct{int}(n)        & \text{integer types} \\
         & \mathct{bits}(a, o, l) & \text{bitfields} \\
         & \mathct{port}          & \text{ports} \\
         & \mathct{table}         & \text{tables} \\
\end{align*}

\begin{enumerate}
\item $\mathct{int}(n)$ types are unsigned integers with a bit-width of size \textit{n}.
\item $\mathct{bits}$ types are bitfields within the storage space of the virtual machine. Bitfields are defined as having an \textit{address space} that denote which area of storage they reside: packet, header, key, meta, ingress\_port, and physical\_port. A bitfield must also specify its length in bits as well as its offset from bit 0 of the address space, again in bits.
\item $\mathct{port}$ types represent numbered ports. Some reserved ports are named, and occupy a static number. For example, the $\mathct{drop}$ port is assigned to 0.
\item $\mathct{table}$ types are data structures that contain all other Pip constructs. A table has a \textit{key register} to be matched against. The programmer defines the value of the key register, which is computed at runtime. Tables have \textit{rules} which, if equal to the key register, will execute a block of actions.
\end{enumerate}

\subsection{Inference Rules}
\subsection{Definitions}
Function \textbf{key(\textit{term})} will return the \textit{key} of \textit{term} if and only if \textit{term} is a table. \\
Function \textbf{type(\textit{term})} will return the type of any typed term, \textit{term}.

\subsection{Expressions}
\begin{align*}
  \text{expressions} ::=~& \mathct{int}(w) n    & \text{where} \ w \ \text{and} \ n \ \text{are integer literals.}\\
  & | \ \mathct{port} \ n   & \text{where } n \text{ is an integer literal.}\\
  & \ \ \mathct{bits} \ as \ pos \ len &\text{where } pos \text{ and } len \text{ are integer literals.} \\ & &\text{and } as \text{ is an address space.}\\
  & | \ \mathct{miss}\\
  & | \ \mathct{ref} \ id    &\text{where } id \text{ is the name of a table.}
\end{align*}
\subsection{Actions}

Actions are instructions that either have no parameters, a typed expression as a parameter, or another actions as a parameter. Actions do not have a type.
\begin{enumerate}
  \item $\mathct{write} \ action$ - $action$ must be an action.
  \item $\mathct{clear}$ takes no parameters.
  \item $\mathct{drop}$ takes no parameters.
  \item $\mathct{match}$ takes no parameters.
  \item $\mathct{goto}$ takes a parameter of type $\mathct{table}$.
  \item $\mathct{output}$ takes a parameter of type $\mathct{port}$.
  \item $\mathct{advance}$ takes a parameter of type $\mathct{int}(n)$.
  \item $\mathct{copy}$ takes two parameters of type $\mathct{bits}$ and a parameter of type $\mathct{int}(n)$.
  \item $\mathct{set}$ takes a parameter of type $\mathct{bits}$ and a parameter of type $\mathct{int}(n)$.
\end{enumerate}

TODO: create a system that represents values which have precision.

\subsubsection{Type System Issues}
Pip has a type system that ensures instructions can be written correctly, but does not guarantee that they produce meaningful results. For example, the programmer can copy from anywhere in the buffer to anywhere else in the buffer. Using named bitfields gives the programmer an alternative to bit manipulation, but the programmer is not restricted to them. Pip's storage-based model means that it lacks an object model or declaration system. A declaration system would mitigate, and possibly eliminate memory access violations at the expense of freedom. The similar dataplane programming language, Steve, attempted to create a declaration system for packet switching.

Steve has a user-defined type known as a \textit{layout} that allows programmers to dynamically define named bitfields within the packet. An example Steve layout follows:
\begin{verbatim}
layout ethernet {
  dst : uint(48);
  src : uint(48);
  type : uint(16);
}
\end{verbatim}
Once a layout has been defined, the programmer can \textit{extract} the individual headers and use them like variables.
\begin{verbatim}
extract ethernet.type;

if(eth.type == 0x600) {
 // ...
}
\end{verbatim}
Until the programmer has explicitly \textit{extracted} a named field, it is not usable. Thus, the only part of the buffer accessible to the programmer are the fields they have explicitly defined and stated they wish to access. Barring poor definition, there is no possible way for the programmer to overwrite their working buffer or access beyond its boundary. Defining a similar declaration system in Pip would be a step toward fixing this issue.
