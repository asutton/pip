#pragma once

#include <pip/pcap.hpp>

#include <cstdint>
#include <cstring>
#include <iostream>
#include <vector>
#include <cassert>

#include <netinet/in.h>

#define SIZE_ETHERNET 14

namespace pip
{
namespace cap
{
  struct eth_header
  {
    eth_header(const packet& pkt)
      : pkt(pkt)
    {
      std::size_t i;
      for(i = 0; i < mac_addr_len; ++i)
	std::memcpy(&dst_mac[i], pkt.data() + i, 1);

      for(; i < mac_addr_len * 2; ++i)
	std::memcpy(&src_mac[i - mac_addr_len], pkt.data() + i, 1);

      std::memcpy(&ethertype, pkt.data() + i, 2);
    }

    void print(std::ostream& os) const
    {
      std::cout << "destination mac: ";
      for(int i = 0; i < 6; ++i)
      	os << '\t' << std::hex << (unsigned)dst_mac[i];

      os << '\n' << "source mac: ";
      for(int i = 0; i < 6; ++i)
      	os << '\t' << std::hex << (unsigned)src_mac[i];
      
      os << '\n';
      os << "ethertype: " << std::hex << ethertype << '\n';
    }      
    
    std::uint8_t dst_mac[6];
    std::uint8_t src_mac[6];
    std::uint16_t ethertype;

    const packet& pkt;

    private:
    const int mac_addr_len = 6;
  };

  struct ipv4_header
  {
    ipv4_header(const eth_header& eth)
      :eth(eth)
    {
      // ensure this is an ipv4 packet
      assert(eth.ethertype == 0x0800);

      std::memcpy(&vhl, eth.pkt.data() + SIZE_ETHERNET, 1);      
      std::memcpy(&tos, eth.pkt.data() + SIZE_ETHERNET + 1, 1);
      std::memcpy(&len, eth.pkt.data() + SIZE_ETHERNET + 2, 2);
      std::memcpy(&id, eth.pkt.data() + SIZE_ETHERNET + 4, 2);
      std::memcpy(&frag_offset, eth.pkt.data() + SIZE_ETHERNET + 6, 2);
      std::memcpy(&ttl, eth.pkt.data() + SIZE_ETHERNET + 8, 1);
      std::memcpy(&protocol, eth.pkt.data() + SIZE_ETHERNET + 9, 1);
      std::memcpy(&checksum, eth.pkt.data() + SIZE_ETHERNET + 10, 2);
      std::memcpy(&saddr, eth.pkt.data() + SIZE_ETHERNET + 12, 4);
      std::memcpy(&daddr, eth.pkt.data() + SIZE_ETHERNET + 16, 4);
    }

    void print(std::ostream& os)
    {
      os << "version: " << (unsigned)(vhl << 4) << '\n';
      os << "tos: " << (unsigned)tos << '\n';
      os << "len: " << ntohs(len) << '\n';
      os << "id: " << ntohs(id) << '\n';
      os << "frag_offset: " << ntohs(frag_offset) << '\n';
      os << "ttl: " << (unsigned)ttl << '\n';
      os << "proto: " << (unsigned)protocol << '\n';
    }
    
    uint8_t vhl; // version << 4 | header length >> 2
    uint8_t tos;
    uint16_t len;
    uint16_t id;
    uint16_t frag_offset;
    uint8_t ttl;
    uint8_t protocol;
    uint16_t checksum;
    uint32_t saddr;
    uint32_t daddr;

  private:
    const eth_header& eth;
  };
} // namespace cap
} // namespace pip
